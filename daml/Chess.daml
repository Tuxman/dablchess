-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

daml 1.2
module Chess where

import Rules.Draw
import Rules.Main
import Rules.SplitState
import Types

-- Logic to handle games.
type GameId = Text
type GameContractIds = (ContractId ActiveSideOfGame, ContractId PassiveSideOfGame)

template GameProposal
  with
    gameId : GameId
    proposer : Party
    desiredSide : Side
    opponent : Party
    operator : Party
  where
    signatory proposer
    -- Only one game from proposer with the same id
    key (proposer, gameId) : (Party, GameId)
    maintainer key._1

    controller opponent can
      Accept : ContractId GameAccept
        do create GameAccept with ..

template GameAccept
  with
    gameId : GameId
    proposer : Party
    desiredSide : Side
    opponent : Party
    operator : Party
  where
    signatory proposer, opponent

    controller operator can
      Start : ContractId Game
        do create Game with ..

template Game
  with
    gameId : GameId
    proposer : Party
    desiredSide : Side
    opponent : Party
    operator : Party
  where
    signatory proposer, opponent, operator
    key (operator, gameId) : (Party, GameId)
    maintainer key._1
    controller operator can
      nonconsuming Begin : (ContractId ActiveSideOfGame, ContractId PassiveSideOfGame, ContractId OperatorRole)
        do
          let (activeSide, passiveSide) =
                case desiredSide of
                  White -> (proposer, opponent)
                  Black -> (opponent, proposer)

          activeId <- create ActiveSideOfGame with
                          player = activeSide
                          opponent = passiveSide
                          active = Rules.SplitState.initSplitState White
                          side = White
                          flag = True
                          ..
          passiveId <- create PassiveSideOfGame with
                          player = passiveSide
                          opponent = activeSide
                          passive = Rules.SplitState.initSplitState Black
                          side = Black
                          flag = True
                          ..
          gameRoleId <- create OperatorRole with ..
          return (activeId, passiveId, gameRoleId)

      End : ContractId GameResult
        with
          game : Optional GameState
          drawOrWinner : DrawOrWinner Party
        do
          create GameResult with ..

template GameResult
  with
    opponent : Party
    proposer : Party
    gameId : GameId
    operator : Party
    game : Optional GameState
    drawOrWinner : DrawOrWinner Party
  where
    signatory proposer, opponent, operator

type SideKey = (Party, GameId, Party, Bool)

template PassiveSideOfGame
  with
    player : Party
    side : Side
    operator : Party
    opponent : Party
    gameId : GameId
    passive : SplitGameState
    flag : Bool
  where
    signatory player, operator
    key (operator, gameId, player, flag) : SideKey
    maintainer key._1

    controller operator can
      Activate : ContractId ActiveSideOfGame
        with
          active : SplitGameState
        do create ActiveSideOfGame with flag = not flag, ..
      DeclareWinnerPassive : ContractId GameResult --
        with
          result : ContractId GameResult
        do return result

    controller player can
      Resign : ContractId Surrender
        do create Surrender with activeSurrender = False, ..
      AskForADraw : ContractId DrawRequest
        do create DrawRequest with ..

-- It is the active side's turn.
template ActiveSideOfGame
  with
    player : Party
    side : Side
    operator : Party
    opponent : Party
    gameId : GameId
    active : SplitGameState
    flag :  Bool
  where
    signatory player, operator
    key (operator, gameId, player, flag) : SideKey
    maintainer key._1

    controller player can
      nonconsuming Move : ContractId ActiveAction
        with
          from : Coord
          to : Coord
          promote : Optional PieceType
        do
          let move = Some ChessMove with by = side, ..
          create ActiveAction with move, ..

      nonconsuming ClaimDraw : ContractId ActiveAction
        do
          create ActiveAction with move = None, ..

      Forfeit : ContractId Surrender
        do
          create Surrender with activeSurrender = True, ..

    controller operator can
      -- operator can only take this action after receiving a unique Move,
      Inactivate : ContractId PassiveSideOfGame
        with
          passive : SplitGameState
        do
          create PassiveSideOfGame with flag = not flag, ..

      DeclareWinnerActive : ContractId GameResult --
        with
          result : ContractId GameResult
        do
          return result

template Surrender
  with
    player : Party
    operator : Party
    gameId : GameId
    opponent : Party
    activeSurrender : Bool
    flag : Bool
  where
    signatory operator, player

    key (operator, gameId) : (Party, GameId)
    maintainer key._1

    controller operator can
      ArchiveSurrenderByOperator : ()
        do return ()

template DrawRequest
  with
    player : Party
    operator : Party
    gameId : GameId
    opponent : Party
    side : Side
    -- reveal : Bool -- add?
    flag : Bool
  where
    signatory operator, player
    observer opponent

    key (operator, gameId, player) : (Party, GameId, Party)
    maintainer key._1

    controller opponent can
      AcceptDrawRequest : ContractId AcceptedDraw
        do
        (activeId, activeState) <- fetchByKey @ActiveSideOfGame (operator, gameId, opponent, flag)
        archive activeId
        create AcceptedDraw with ..

template AcceptedDraw
  with
    player : Party
    operator : Party
    gameId : GameId
    opponent : Party
    side : Side
  where
    signatory operator
    key (operator, gameId) : (Party, GameId)
    maintainer key._1

    controller operator can
      ArchiveAcceptedDrawbyOperator : ()
        do return ()


template ActiveAction
  with
    player : Party
    operator : Party
    gameId : GameId
    opponent : Party
    move : Optional ChessMove     -- None = ClaimDraw
    flag : Bool
  where
    signatory operator

-- We track the return type to make tests easier to undertand.
-- It isn't necessary for the full operation of the game.
data AdvanceResult
  = StateHasMoved   -- Duplicate Move/ClaimDraw's, need to clean up the rest
  | GameEnd (ContractId GameResult)
  | NextState GameContractIds

template OperatorRole
  with
    operator : Party
    gameId : GameId
  where
    signatory operator

    key (operator, gameId) : (Party, GameId)
    maintainer key._1

    controller operator can
      -- operator's reaction to the existence of an ActiveAction
      nonconsuming AdvancePlay : AdvanceResult
        with
          activeActionId : ContractId ActiveAction
        do
          -- Look up move information from ActiveAction and archive it
          action <- fetch activeActionId
          let player = action.player
              opponent = action.opponent
              move = action.move
          exercise activeActionId Archive

          -- figure out global state
          activeIdOpt <- lookupByKey @ActiveSideOfGame (operator, gameId, player, action.flag)
          case activeIdOpt of
            None  -> do return StateHasMoved
            Some activeId -> do
              activeState <- fetch activeId
              (passiveId, passiveState) <- fetchByKey @PassiveSideOfGame (operator, gameId, opponent, action.flag)
              let gameState = if activeState.side == White
                              then joinGameStates activeState.active passiveState.passive
                              else joinGameStates passiveState.passive activeState.active
                  moveSide = activeState.side
              case move of
                None  ->  -- claimDraw?
                  case checkDraw gameState of
                    None ->
                      do -- not a draw
                        return $ NextState (activeId, passiveId)
                    (Some drawType) ->
                      do
                        let drawOrWinner = Draw drawType
                        (gameStartId, gameStart) <- fetchByKey @Game (operator, gameId)
                        gameResultId <- exercise gameStartId End with game = Some gameState, ..
                        exercise activeId DeclareWinnerActive with result = gameResultId
                        exercise passiveId DeclareWinnerPassive with result = gameResultId
                        return $ GameEnd gameResultId

                Some m ->
                  case tryMove gameState m of
                    -- determine potential winner
                    DrawOrWinner dow ->
                      let drawOrWinner =
                            case dow of
                              Draw dt -> Draw dt
                              Winner side -> if side == moveSide then Winner activeState.player else Winner activeState.opponent
                          game = (gameState with moves = m :: gameState.moves)
                      in
                      do
                        (gameStartId, gameStart) <- fetchByKey @Game (operator, gameId)
                        gameResultId <- exercise gameStartId End with game = Some game, ..
                        exercise activeId DeclareWinnerActive with result = gameResultId
                        exercise passiveId DeclareWinnerPassive with result = gameResultId
                        return $ GameEnd gameResultId
                    Error e ->
                      do
                        --abort e  -- What mechanism exists to warn to alert the user?
                        let () = traceRaw ("Error: " <> e) ()
                        return $ NextState (activeId, passiveId)
                    -- alternate states
                    NewState newJoinedState ->
                      let whiteState = splitGameStateOfSide White newJoinedState
                          blackState = splitGameStateOfSide Black newJoinedState
                          (active, passive) =
                            case moveSide of
                              White -> (blackState, whiteState)
                              Black -> (whiteState, blackState)
                      in
                      do
                        passiveId' <- exercise activeId Inactivate with passive
                        activeId' <- exercise passiveId Activate with active
                        return $ NextState (activeId', passiveId')

      -- operator's reaction to the existence of an Surrender
      nonconsuming AcknowledgeSurrender : ContractId GameResult
        do
          (sId, surrender) <- fetchByKey @Surrender (operator, gameId)
          exercise sId ArchiveSurrenderByOperator
          (gameStartId, _gameStart) <- fetchByKey @Game (operator, gameId)
          gameResultId <- exercise gameStartId End with game = None, drawOrWinner = Winner surrender.opponent, ..
          if surrender.activeSurrender
          then do
            (passiveId, _passiveState) <- fetchByKey @PassiveSideOfGame (operator, gameId, surrender.opponent, surrender.flag)
            exercise passiveId DeclareWinnerPassive with result = gameResultId
            return gameResultId
          else do
            (activeId, _activeState) <- fetchByKey @ActiveSideOfGame (operator, gameId, surrender.opponent, surrender.flag)
            exercise activeId DeclareWinnerActive with result = gameResultId
            return gameResultId

      nonconsuming AcknowledgeAcceptedDraw : ContractId GameResult
        do
          (adId, acceptedDraw) <- fetchByKey @AcceptedDraw (operator, gameId)
          (gameStartId, _gameStart) <- fetchByKey @Game (operator, gameId)
          exercise adId ArchiveAcceptedDrawbyOperator
          exercise gameStartId End with game = None, drawOrWinner = Draw (PlayerDraw acceptedDraw.side)